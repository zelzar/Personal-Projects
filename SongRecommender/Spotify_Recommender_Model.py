# -*- coding: utf-8 -*-
"""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cJLUN4f4NFdmuazoFQJLmuQfJ19PR75u

# Background of Project

In this exploratory data analysis, we delve into the world of music through the lens of the Spotify Songs dataset. Abundant with information on diverse songs, including their features, popularity metrics, and playlist associations, our objective is to uncover patterns, trends, and relationships embedded within the data. This analytical endeavor aims to provide insights into the myriad factors that influence the success of a song, offering a comprehensive understanding of the intricate dynamics that shape the musical landscape.

## *Problem Definition*

One of the challenges in the music industry is understanding the factors that contribute to the popularity of songs. Artists, producers, and streaming platforms seek insights into the characteristics of successful songs to tailor their strategies. The problem is to identify patterns and trends within the Spotify Songs data set that can shed light on the features associated with highly popular songs. Main Problem: Ways to enhance music discovery using similarity features.

### Loading and Preparing Data: Performing Data Wrangling, Munging, and Cleaning from the original CSV File
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from collections import namedtuple

# Load the dataset
spotify_songs = pd.read_csv('./spotify_songs.csv')

# Checking for missing values and duplicates
missing_values = spotify_songs.isnull().sum().sum()
duplicates = spotify_songs.duplicated().sum()

# Removing rows with missing values
spotify_songs = spotify_songs.dropna()

# Replace missing popularity with the mean
average_track_popularity = spotify_songs['track_popularity'].mean()
spotify_songs['track_popularity'].fillna(average_track_popularity, inplace=True)

# Remove duplicate entries
spotify_songs = spotify_songs.sort_values('track_popularity', ascending=False).drop_duplicates(['track_name', 'track_artist'])

# Convert release date to datetime
spotify_songs['track_album_release_date'] = pd.to_datetime(spotify_songs['track_album_release_date'])

# Extract day of the week
spotify_songs['release_day'] = spotify_songs['track_album_release_date'].dt.day_name()

#a numeric identifier for each track
spotify_songs['track_id_numeric'] = pd.factorize(spotify_songs['track_id'])[0]

"""# Exploratory Data Analysis

### 1. Check the distribution of songs in each genre
"""

genre_counts = spotify_songs['playlist_genre'].value_counts()
sub_genre_counts = spotify_songs['playlist_subgenre'].value_counts()

# Print the genre distribution
print("Genre Distribution:")
print(genre_counts)

"""###2. Top Artists in the Dataset"""

# Top Artists
top_artists = spotify_songs['track_artist'].value_counts().head(10)
print("Top 10 Artists:")
print(top_artists)

"""### 3. Pie chart for Sub Genre Distribution"""

sub_genre_data = pd.DataFrame({'SubGenre': sub_genre_counts.index, 'Count': sub_genre_counts.values})

# Pie chart for Sub Genre Distribution
plt.figure(figsize=(8, 8))
plt.pie(sub_genre_data['Count'], labels=sub_genre_data['SubGenre'], autopct='%1.1f%%', startangle=90)
plt.title("Sub Genre Distribution of Songs")
plt.show()

"""### 4. Popularity Trends Over Time"""

plt.figure(figsize=(12, 6))
plt.plot(spotify_songs['track_album_release_date'], spotify_songs['track_popularity'], color='skyblue')
plt.title("Popularity Trends Over Time")
plt.xlabel("Release Date")
plt.ylabel("Song Popularity")
plt.show()

"""### 5. 15 of the most popular songs from the dataset

"""

top_15_popular_songs = spotify_songs.nlargest(15, 'track_popularity')[['track_name', 'track_artist', 'track_popularity']]
print(top_15_popular_songs)

"""### 4. Proportion of Genres in Top Playlists by Day"""

top_playlists = spotify_songs[(spotify_songs['track_popularity'] >= 80) &
                              ~spotify_songs['playlist_genre'].isnull() &
                              ~spotify_songs['release_day'].isnull() &
                              (spotify_songs['release_day'] != "NA")]

genre_prop_by_day = top_playlists.groupby(['release_day', 'playlist_genre']).size().reset_index(name='count')
genre_prop_by_day['prop'] = genre_prop_by_day['count'] / genre_prop_by_day.groupby('release_day')['count'].transform('sum')

plt.figure(figsize=(10, 6))
for genre in genre_prop_by_day['playlist_genre'].unique():
    genre_data = genre_prop_by_day[genre_prop_by_day['playlist_genre'] == genre]
    plt.bar(genre_data['release_day'], genre_data['prop'], label=genre)

plt.title("Proportion of Genres in Top Playlists by Day")
plt.xlabel("Day of the Week")
plt.ylabel("Proportion")
plt.legend(title='Playlist Genre', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""### 5. Audio Feature Distribution
We can visualize the distributions of various audio features such as danceability, energy, loudness, etc, and xplore whether there are any noticeable patterns or differences between genres.
"""

audio_features = ['danceability', 'energy', 'valence', 'loudness', 'tempo']
plt.figure(figsize=(16, 8))
for i, feature in enumerate(audio_features, 1):
    plt.subplot(2, 3, i)
    sns.histplot(spotify_songs[feature], kde=True)
    plt.title(f"Distribution of {feature}")
plt.tight_layout()
plt.show()

# Boxplot of Audio Features by Genre
plt.figure(figsize=(16, 8))
for i, feature in enumerate(audio_features, 1):
    plt.subplot(2, 3, i)
    sns.boxplot(x='playlist_genre', y=feature, data=spotify_songs)
    plt.title(f"{feature} by Genre")
    plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""###6. Correlation Heatmap for Audio Features in Spotify Songs

This heatmap visualizes the degree of correlation between features such as danceability, energy, valence, loudness, and tempo. More brighter colors will indicate stronger correlations, providing insights into how these musical attributes influence each other.
"""

audio_features = ['danceability', 'energy', 'valence', 'loudness', 'tempo']

# Calculate the correlation matrix
cor_matrix = spotify_songs[audio_features].corr()

# Plot the correlation heatmap
plt.figure(figsize=(8, 8))
sns.heatmap(cor_matrix, annot=True, cmap="PuRd", square=True)
plt.title("Correlation Heatmap for Audio Features")
plt.show()

"""We can see that some of the features show more connection or correlations than the others like more loudness relates to more energy etc.

# RECOMMENDATION MODEL

##1.Using Cosine similarity
"""

# Cosine similarity function
def cosine_similarity(x, y):
    return np.sum(x * y) / (np.sqrt(np.sum(x**2)) * np.sqrt(np.sum(y**2)))

"""##2.Using Euclidean Distance function:"""

# Euclidean distance function
from scipy.spatial.distance import euclidean
def euclidean_distance(x, y):
    return euclidean(x, y)

"""###Getting similar songs using both the Functions"""

# Function to get similar songs using Cosine Similarity
def get_similar_songs(song_id, n=5):
    song_features = spotify_songs[["danceability", "energy", "key", "loudness",
                                   "mode", "speechiness", "acousticness",
                                   "instrumentalness", "liveness", "valence", "tempo"]]

    song_features = song_features.apply(pd.to_numeric, errors='coerce')
    query_features = song_features.loc[spotify_songs["track_id"] == song_id].squeeze().values

    # Calculating the cosine similarity
    similarity_scoresCS = song_features.apply(lambda x: cosine_similarity(x, query_features), axis=1)

    #Getting Euclidian Similarity
    similarity_scoresED = song_features.apply(lambda x: euclidean_distance(x, query_features), axis=1)

    # Getting indices of most similar songs
    similar_song_indices_CS = similarity_scoresCS.sort_values(ascending=False).index[:n+1]
    similar_song_indices_ED = similarity_scoresED.sort_values(ascending=True).index[:n+1]

    return similar_song_indices_CS, similar_song_indices_ED

# Selecting a random seed
np.random.seed(143)
random_song_index = np.random.choice(range(len(spotify_songs)))
random_song_id = spotify_songs.loc[random_song_index, "track_id"]

# Calling the functions
similar_songs_CS, similar_songs_ED = get_similar_songs(random_song_id, n=5)

print("Randomly Selected Song:")
print(spotify_songs.loc[spotify_songs["track_id"] == random_song_id, ["track_name", "track_artist"]])

print("\nSimilar Songs Using the Cosine Function:")
print(spotify_songs.loc[similar_songs_CS[1:6], ["track_name", "track_artist"]])

print("\nSimilar Songs Using the Euclidean Distance Function:")
print(spotify_songs.loc[similar_songs_ED[1:6], ["track_name", "track_artist"]])

"""We can see how after selecting a random songs from the dataset: "Say My Name", the Recommender System uses two different fuctions to find the recommendation. Moreover the two recommendations have a common song aswell which shows how some of the features provide similar recommendtions even though the algorithms are different.

###Genre Similarity between the different Songs
"""

def plot_table(similar_songs, title):
    genres_data = spotify_songs.loc[similar_songs, "playlist_subgenre"]


    genre_counts = genres_data.value_counts().reset_index()
    genre_counts.columns = ["Genre", "Count"]

    print(f"\nGenre Distribution of Similar Songs ({title}):\n")
    print(genre_counts)

# Example usage
plot_table(similar_songs_CS[1:6], "Cosine Similarity")
plot_table(similar_songs_ED[1:6], "Euclidean Distance")

"""The Table verifies that the Model does not simply work to choose similar genre based songs as recommendations however uses the cosine similarity function and the Euclidian Distance function on the different features of the songs to recommend similar choices.

# Conclusion

The exploration of the Spotify Songs dataset has provided profound insights into the intricacies of music popularity and the diverse characteristics of songs. This includes trends, distributions, and top-performing songs, contributing significantly to a detailed comprehension of the factors influencing song popularity.

I have also upgraded the recommendar model to incorporate two distinct functions to facilitate the collaborative filtering approach. This enhancement not only refines the efficiency and clarity of the recommendation process but also broadens the scope of diversity in song suggestions beyond traditional genre boundaries.

This project stands as a valuable asset for artists, producers, and streaming platforms, offering not only insights into individual song characteristics but also a way to search more dynamic and inclusive music recommendation. The collaboration of visualizations, statistical analysis, and machine learning techniques has proven instrumental in navigating the features of the dataset, allowing for the extraction of meaningful conclusions.

Looking forward, this project can be further refineed by integrating additional song features. Incorporating sentiment analysis of lyrics or leveraging advanced audio characteristics will contribute to offering more diverse recommendations.Implementing real-time model updates will enable the system to adapt dynamically to evolving user preferences and changing music trends.T These enhancements will also aim to improve the recommendation system's performance and user experience.
"""
